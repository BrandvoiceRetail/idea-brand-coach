/**
 * Abstract Markdown PDF Exporter
 *
 * Base class for generating PDF exports from markdown content.
 * Provides a consistent interface and shared utilities for all PDF exports.
 *
 * Strategy: Generate markdown first, then convert to PDF using jsPDF.
 * This ensures consistent formatting and makes it easy to add new export types.
 */

import jsPDF from 'jspdf';
import * as md from './templates/formatters/MarkdownFormatter';

/**
 * PDF export configuration
 */
export interface PDFExportConfig {
  /** Document title */
  title: string;

  /** Subtitle or company name */
  subtitle?: string;

  /** Page orientation */
  orientation?: 'portrait' | 'landscape';

  /** Page format */
  format?: 'a4' | 'letter';

  /** Page margins in mm */
  margins?: {
    top: number;
    right: number;
    bottom: number;
    left: number;
  };

  /** Primary color for headings (RGB) */
  primaryColor?: [number, number, number];

  /** Include generated date */
  includeDate?: boolean;

  /** Footer text */
  footerText?: string;
}

/**
 * Default PDF configuration
 */
export const DEFAULT_PDF_CONFIG: Required<PDFExportConfig> = {
  title: 'Export',
  subtitle: '',
  orientation: 'portrait',
  format: 'a4',
  margins: {
    top: 20,
    right: 20,
    bottom: 20,
    left: 20,
  },
  primaryColor: [30, 64, 175], // Blue
  includeDate: true,
  footerText: 'Generated by IDEA Brand Coach',
};

/**
 * Parsed markdown element
 */
interface MarkdownElement {
  type: 'heading' | 'paragraph' | 'list' | 'blockquote' | 'hr' | 'table' | 'empty';
  level?: number; // For headings (1-6)
  content: string;
  items?: string[]; // For lists
  itemNumbers?: number[]; // Original numbers from markdown for ordered lists
  ordered?: boolean; // For ordered lists
  headers?: string[]; // For tables
  rows?: string[][]; // For tables
}

/**
 * Abstract base class for markdown-based PDF exports
 */
export abstract class MarkdownPDFExporter {
  protected config: Required<PDFExportConfig>;
  protected pdf: jsPDF;
  protected yPosition: number;
  protected pageWidth: number;
  protected pageHeight: number;
  protected contentWidth: number;
  protected lineHeight: number = 6;

  constructor(config: Partial<PDFExportConfig> = {}) {
    this.config = { ...DEFAULT_PDF_CONFIG, ...config };
    this.pdf = new jsPDF(this.config.orientation, 'mm', this.config.format);
    this.pageWidth = this.pdf.internal.pageSize.getWidth();
    this.pageHeight = this.pdf.internal.pageSize.getHeight();
    this.contentWidth = this.pageWidth - this.config.margins.left - this.config.margins.right;
    this.yPosition = this.config.margins.top;
  }

  /**
   * Abstract method: Generate markdown content for export
   * Subclasses must implement this to provide their specific content
   */
  protected abstract generateMarkdown(): string;

  /**
   * Abstract method: Get suggested filename for download
   */
  protected abstract getFilename(): string;

  /**
   * Generate and download the PDF
   */
  async export(): Promise<void> {
    // Reset PDF state
    this.pdf = new jsPDF(this.config.orientation, 'mm', this.config.format);
    this.yPosition = this.config.margins.top;

    // Generate markdown content
    const markdown = this.generateMarkdown();

    // Parse and render markdown to PDF
    this.renderMarkdownToPDF(markdown);

    // Save the PDF
    this.pdf.save(this.getFilename());
  }

  /**
   * Generate PDF blob without downloading
   */
  async generateBlob(): Promise<Blob> {
    // Reset PDF state
    this.pdf = new jsPDF(this.config.orientation, 'mm', this.config.format);
    this.yPosition = this.config.margins.top;

    // Generate markdown content
    const markdown = this.generateMarkdown();

    // Parse and render markdown to PDF
    this.renderMarkdownToPDF(markdown);

    // Return as blob
    return this.pdf.output('blob');
  }

  /**
   * Parse markdown string into elements
   */
  protected parseMarkdown(markdown: string): MarkdownElement[] {
    const lines = markdown.split('\n');
    const elements: MarkdownElement[] = [];
    let i = 0;

    while (i < lines.length) {
      const line = lines[i];

      // Empty line
      if (line.trim() === '') {
        elements.push({ type: 'empty', content: '' });
        i++;
        continue;
      }

      // Horizontal rule
      if (/^---+$/.test(line.trim())) {
        elements.push({ type: 'hr', content: '' });
        i++;
        continue;
      }

      // Heading
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        elements.push({
          type: 'heading',
          level: headingMatch[1].length,
          content: headingMatch[2],
        });
        i++;
        continue;
      }

      // Blockquote
      if (line.startsWith('> ')) {
        let content = line.substring(2);
        i++;
        while (i < lines.length && lines[i].startsWith('> ')) {
          content += '\n' + lines[i].substring(2);
          i++;
        }
        elements.push({ type: 'blockquote', content });
        continue;
      }

      // Unordered list
      if (line.match(/^[-*]\s+/)) {
        const items: string[] = [];
        while (i < lines.length && lines[i].match(/^[-*]\s+/)) {
          items.push(lines[i].replace(/^[-*]\s+/, ''));
          i++;
        }
        elements.push({ type: 'list', content: '', items, ordered: false });
        continue;
      }

      // Ordered list - collect numbered items with their sub-content
      if (line.match(/^\d+\.\s+/)) {
        const items: string[] = [];
        const itemNumbers: number[] = [];

        while (i < lines.length) {
          const currentLine = lines[i];
          const numberedMatch = currentLine.match(/^(\d+)\.\s+(.*)$/);

          if (numberedMatch) {
            // New numbered item - capture the number and content
            itemNumbers.push(parseInt(numberedMatch[1], 10));
            let itemContent = numberedMatch[2];
            i++;

            // Collect all indented sub-content (including sub-bullets)
            while (i < lines.length) {
              const nextLine = lines[i];
              // Check if this is a new top-level numbered item
              if (nextLine.match(/^\d+\.\s+/)) {
                break;
              }
              // Check if this is a heading or horizontal rule (end of list)
              if (nextLine.match(/^#{1,6}\s+/) || nextLine.match(/^---+$/)) {
                break;
              }
              // Empty line might end the list or be between items
              if (nextLine.trim() === '') {
                // Look ahead to see if there's another numbered item
                let hasMoreNumberedItems = false;
                for (let j = i + 1; j < lines.length && j < i + 3; j++) {
                  if (lines[j].match(/^\d+\.\s+/)) {
                    hasMoreNumberedItems = true;
                    break;
                  }
                  if (lines[j].match(/^#{1,6}\s+/) || lines[j].match(/^---+$/)) {
                    break;
                  }
                }
                if (!hasMoreNumberedItems) {
                  break;
                }
                i++;
                continue;
              }
              // Include indented content or sub-bullets as part of this item
              itemContent += ' ' + nextLine.trim();
              i++;
            }

            items.push(itemContent.trim());
          } else {
            // Not a numbered line, end the list
            break;
          }
        }

        if (items.length > 0) {
          elements.push({ type: 'list', content: '', items, itemNumbers, ordered: true });
        }
        continue;
      }

      // Table
      if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('---')) {
        const headers = line.split('|').map(h => h.trim()).filter(h => h);
        i += 2; // Skip header and separator
        const rows: string[][] = [];
        while (i < lines.length && lines[i].includes('|')) {
          const row = lines[i].split('|').map(c => c.trim()).filter(c => c);
          rows.push(row);
          i++;
        }
        elements.push({ type: 'table', content: '', headers, rows });
        continue;
      }

      // Regular paragraph
      let content = line;
      i++;
      while (i < lines.length && lines[i].trim() !== '' && !lines[i].match(/^[#>-]/) && !lines[i].match(/^\d+\./) && !lines[i].includes('|')) {
        content += ' ' + lines[i].trim();
        i++;
      }
      elements.push({ type: 'paragraph', content });
    }

    return elements;
  }

  /**
   * Render parsed markdown elements to PDF
   */
  protected renderMarkdownToPDF(markdown: string): void {
    const elements = this.parseMarkdown(markdown);

    for (const element of elements) {
      this.checkPageBreak(20);

      switch (element.type) {
        case 'heading':
          this.renderHeading(element.content, element.level || 1);
          break;
        case 'paragraph':
          this.renderParagraph(element.content);
          break;
        case 'list':
          this.renderList(element.items || [], element.ordered || false, element.itemNumbers);
          break;
        case 'blockquote':
          this.renderBlockquote(element.content);
          break;
        case 'hr':
          this.renderHorizontalRule();
          break;
        case 'table':
          this.renderTable(element.headers || [], element.rows || []);
          break;
        case 'empty':
          this.yPosition += 1.5; // Reduced from 3
          break;
      }
    }
  }

  /**
   * Check if page break is needed and add new page if necessary
   */
  protected checkPageBreak(additionalSpace: number = 15): boolean {
    if (this.yPosition > this.pageHeight - this.config.margins.bottom - additionalSpace) {
      this.pdf.addPage();
      this.yPosition = this.config.margins.top;
      return true;
    }
    return false;
  }

  /**
   * Render a heading
   */
  protected renderHeading(text: string, level: number): void {
    const sizes: Record<number, number> = {
      1: 22,
      2: 18,
      3: 14,
      4: 12,
      5: 11,
      6: 10,
    };

    const size = sizes[level] || 12;
    // Reduced spacing - only add space before major headings
    const spacingBefore = level === 1 ? 6 : level === 2 ? 5 : 3;
    const spacingAfter = level <= 2 ? 3 : 2;

    this.yPosition += spacingBefore;
    this.checkPageBreak(size + 10);

    this.pdf.setTextColor(...this.config.primaryColor);
    this.pdf.setFontSize(size);
    this.pdf.setFont('helvetica', 'bold');

    // Handle long headings with text wrap
    const processedText = this.stripMarkdownFormatting(text);
    const lines = this.pdf.splitTextToSize(processedText, this.contentWidth);
    this.pdf.text(lines, this.config.margins.left, this.yPosition);
    this.yPosition += lines.length * (size / 2.5) + spacingAfter;

    // Reset text color
    this.pdf.setTextColor(0, 0, 0);
  }

  /**
   * Render a paragraph
   */
  protected renderParagraph(text: string): void {
    this.pdf.setFont('helvetica', 'normal');
    this.pdf.setFontSize(11);
    this.pdf.setTextColor(0, 0, 0);

    const processedText = this.stripMarkdownFormatting(text);
    const lines = this.pdf.splitTextToSize(processedText, this.contentWidth);

    for (const line of lines) {
      this.checkPageBreak();
      this.pdf.text(line, this.config.margins.left, this.yPosition);
      this.yPosition += this.lineHeight;
    }

    this.yPosition += 2; // Reduced from 3
  }

  /**
   * Render a list (ordered or unordered)
   */
  protected renderList(items: string[], ordered: boolean, itemNumbers?: number[]): void {
    this.pdf.setFont('helvetica', 'normal');
    this.pdf.setFontSize(11);
    this.pdf.setTextColor(0, 0, 0);

    items.forEach((item, index) => {
      this.checkPageBreak();

      // Use original number from markdown if available, otherwise fallback to index+1
      const prefix = ordered
        ? `${itemNumbers && itemNumbers[index] !== undefined ? itemNumbers[index] : index + 1}.`
        : 'â€¢';
      const processedItem = this.stripMarkdownFormatting(item);
      const lines = this.pdf.splitTextToSize(processedItem, this.contentWidth - 10);

      // First line with bullet/number
      this.pdf.text(`${prefix} ${lines[0]}`, this.config.margins.left, this.yPosition);
      this.yPosition += this.lineHeight;

      // Subsequent lines indented
      for (let i = 1; i < lines.length; i++) {
        this.checkPageBreak();
        this.pdf.text(lines[i], this.config.margins.left + 8, this.yPosition);
        this.yPosition += this.lineHeight;
      }
    });

    this.yPosition += 2; // Reduced from 3
  }

  /**
   * Render a blockquote
   */
  protected renderBlockquote(text: string): void {
    this.pdf.setFont('helvetica', 'italic');
    this.pdf.setFontSize(10);
    this.pdf.setTextColor(100, 100, 100);

    // Draw left border
    const startY = this.yPosition;
    const processedText = this.stripMarkdownFormatting(text);
    const lines = this.pdf.splitTextToSize(processedText, this.contentWidth - 15);

    for (const line of lines) {
      this.checkPageBreak();
      this.pdf.text(line, this.config.margins.left + 10, this.yPosition);
      this.yPosition += this.lineHeight;
    }

    // Draw border line
    this.pdf.setDrawColor(200, 200, 200);
    this.pdf.setLineWidth(0.5);
    this.pdf.line(
      this.config.margins.left + 3,
      startY - 3,
      this.config.margins.left + 3,
      this.yPosition - 3
    );

    this.yPosition += 5;
    this.pdf.setTextColor(0, 0, 0);
  }

  /**
   * Render a horizontal rule
   */
  protected renderHorizontalRule(): void {
    this.yPosition += 5;
    this.pdf.setDrawColor(200, 200, 200);
    this.pdf.setLineWidth(0.5);
    this.pdf.line(
      this.config.margins.left,
      this.yPosition,
      this.pageWidth - this.config.margins.right,
      this.yPosition
    );
    this.yPosition += 8;
  }

  /**
   * Render a table
   */
  protected renderTable(headers: string[], rows: string[][]): void {
    if (headers.length === 0) return;

    this.pdf.setFontSize(10);
    const colWidth = this.contentWidth / headers.length;
    const startX = this.config.margins.left;

    // Headers
    this.pdf.setFont('helvetica', 'bold');
    this.pdf.setFillColor(240, 240, 240);
    this.pdf.rect(startX, this.yPosition - 4, this.contentWidth, 8, 'F');

    headers.forEach((header, i) => {
      const processedHeader = this.stripMarkdownFormatting(header);
      this.pdf.text(processedHeader, startX + i * colWidth + 2, this.yPosition);
    });

    this.yPosition += 8;

    // Rows
    this.pdf.setFont('helvetica', 'normal');
    for (const row of rows) {
      this.checkPageBreak(10);
      row.forEach((cell, i) => {
        const processedCell = this.stripMarkdownFormatting(cell);
        const truncated = processedCell.length > 30 ? processedCell.substring(0, 27) + '...' : processedCell;
        this.pdf.text(truncated, startX + i * colWidth + 2, this.yPosition);
      });
      this.yPosition += 6;
    }

    this.yPosition += 5;
  }

  /**
   * Strip markdown formatting from text (bold, italic, links, etc.)
   */
  protected stripMarkdownFormatting(text: string): string {
    return text
      .replace(/\*\*(.+?)\*\*/g, '$1') // Bold
      .replace(/\*(.+?)\*/g, '$1') // Italic
      .replace(/__(.+?)__/g, '$1') // Bold alt
      .replace(/_(.+?)_/g, '$1') // Italic alt
      .replace(/\[(.+?)\]\(.+?\)/g, '$1') // Links
      .replace(/`(.+?)`/g, '$1') // Inline code
      .replace(/~~(.+?)~~/g, '$1'); // Strikethrough
  }

  // Re-export markdown formatter utilities for subclasses
  protected static md = md;
}

/**
 * Export markdown formatter utilities for external use
 */
export { md as MarkdownUtils };
